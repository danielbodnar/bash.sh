#!/usr/bin/env bash
#
# HZ: Standard Template for bash/zsh developing.
# Version: 20180509
# License: MIT
# Site: https://github/hedzr/bash.sh
# 

# Usages:
#   $ copy `bash.config` to `/usr/local/bin`, and source it in your bash script file.
#   see also `example/cpu`
# Use installer:
#   $ curl -sSL https://hedzr.com/bash.sh/installer | sudo bash -s
#

#### HZ Tail BEGIN ####
in_debug()       { [[ $DEBUG -eq 1 ]]; }
is_root()        { [ "$(id -u)" = "0" ]; }
is_bash()        { [ -n "$BASH_VERSION" ]; }
is_bash_t2()     { [ ! -n "$BASH" ]; }
is_zsh()         { [ -n "$ZSH_NAME" ]; }
is_darwin()      { [[ $OSTYPE == *darwin* ]]; }
is_linux()       { [[ $OSTYPE == *linux* ]]; }
in_sourcing()    { is_zsh && [[ $ZSH_EVAL_CONTEXT == 'toplevel' ]] || [[ $(basename -- "$0") != $(basename -- "${BASH_SOURCE[0]}") ]]; }
headline()       { printf "\e[0;1m$@\e[0m:\n"; }
headline-begin() { printf "\e[0;1m"; }  # for more color, see: shttps://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux
headline-end()   { printf "\e[0m:\n"; } # https://misc.flogisoft.com/bash/tip_colors_and_formatting
printf-black()   { printf "\e[0;30m$@\e[0m:\n"; }
printf-red()     { printf "\e[0;31m$@\e[0m:\n"; }
printf-green()   { printf "\e[0;32m$@\e[0m:\n"; }
printf-yellow()  { printf "\e[0;33m$@\e[0m:\n"; }
printf-blue()    { printf "\e[0;34m$@\e[0m:\n"; }
printf-purple()  { printf "\e[0;35m$@\e[0m:\n"; }
printf-cyan()    { printf "\e[0;36m$@\e[0m:\n"; }
printf-white()   { printf "\e[0;37m$@\e[0m:\n"; }
debug()          { in_debug && printf "\e[0;38;2;133;133;133m$@\e[0m\n" || :; }
debug-begin()    { printf "\e[0;38;2;133;133;133m"; }
debug-end()      { printf "\e[0m\n"; }
debug-info()     {
	debug-begin
	cat <<-EOF
	    in_debug: $(in_debug && echo Y || echo '-')
	     is_root: $(is_root && echo Y || echo '-')
	     is_bash: $(is_bash && echo Y || echo '-')
	  is_bash_t2: $(is_bash_t2 && echo Y || echo '-')
	      is_zsh: $(is_zsh && echo Y || echo '-')
	 in_sourcing: $(in_sourcing && echo Y || echo '-')
	EOF
	debug-end
}
commander ()    {
  local self=$1; shift;
  local cmd=${1:-usage}; [ $# -eq 0 ] || shift;
  #local self=${FUNCNAME[0]}
  case $cmd in
    help|usage|--help|-h|-H) "$self-usage" "$@"; ;;
    funcs|--funcs|--functions|--fn|-fn)  script.functions "^$self"; ;;
    *)
      if [ "$(type -t $self-$cmd-entry)" == "function" ]; then
        "$self-$cmd-entry" "$@"
      else
        "$self-$cmd" "$@"
      fi
      ;;
  esac
}
script.functions () {
  # shellcheck disable=SC2155
  local fncs=$(declare -F -p | cut -d " " -f 3|grep -vP "^[_-]"|grep -vP "\\."|grep -vP "^[A-Z]"); # Get function list
  if [ $# -eq 0 ]; then
  	echo "$fncs"; # not quoted here to create shell "argument list" of funcs.
  else
  	echo "$fncs"|grep -P "$@"
  fi
  #declare MyFuncs=($(script.functions));
}
main.do.sth()    {
	set -e
	trap 'previous_command=$this_command; this_command=$BASH_COMMAND' DEBUG
	trap '[ $? -ne 0 ] && echo FAILED COMMAND: $previous_command with exit code $?' EXIT
	MAIN_DEV=${MAIN_DEV:-eth0}
	MAIN_ENTRY=${MAIN_ENTRY:-_my.main.do.sth}
	# echo $MAIN_ENTRY - "$@"
	in_debug && debug-info
	$MAIN_ENTRY "$@"
	trap - EXIT
	${HAS_END:-$(false)} && debug-begin && echo -n 'Success!' && debug-end
}
DEBUG=${DEBUG:-0}
is_darwin && realpathx(){ [[ $1 == /* ]] && echo "$1" || echo "$PWD/${1#./}"; } || realpathx () { readlink -f $*; }
in_sourcing && { CD=${CD}; debug ">> IN SOURCING, \$0=$0, \$_=$_"; } || { SCRIPT=$(realpathx $0) && CD=$(dirname $SCRIPT) && debug ">> '$SCRIPT' in '$CD', \$0='$0','$1'."; }
#main.do.sth "$@"
#### HZ Tail END ####
